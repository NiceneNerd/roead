<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="github crates-io docs-rs"><title>cxx - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-b25d77b18a16a9a4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="cxx" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0-nightly (506052d49 2024-08-16)" data-channel="nightly" data-search-js="search-ef54e092fea9c776.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-cb0df477c2d67d00.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../cxx/index.html">cxx</a><span class="version">1.0.126</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Aliases</a></li><li><a href="#attributes">Attribute Macros</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">cxx</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/cxx/lib.rs.html#1-550">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><a href="https://github.com/dtolnay/cxx"><img src="https://img.shields.io/badge/github-8da0cb?style=for-the-badge&amp;labelColor=555555&amp;logo=github" alt="github" /></a> <a href="https://crates.io/crates/cxx"><img src="https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&amp;labelColor=555555&amp;logo=rust" alt="crates-io" /></a> <a href="https://docs.rs/cxx"><img src="https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&amp;labelColor=555555&amp;logo=docs.rs" alt="docs-rs" /></a></p>
<br>
<p>This library provides a <strong>safe</strong> mechanism for calling C++ code from Rust
and Rust code from C++, not subject to the many ways that things can go
wrong when using bindgen or cbindgen to generate unsafe C-style bindings.</p>
<p>This doesn’t change the fact that 100% of C++ code is unsafe. When auditing
a project, you would be on the hook for auditing all the unsafe Rust code
and <em>all</em> the C++ code. The core safety claim under this new model is that
auditing just the C++ side would be sufficient to catch all problems, i.e.
the Rust side can be 100% safe.</p>
<br>
<p><em>Compiler support: requires rustc 1.67+ and c++11 or newer</em><br>
<em><a href="https://github.com/dtolnay/cxx/releases">Release notes</a></em></p>
<br>
<h2 id="guide"><a class="doc-anchor" href="#guide">§</a>Guide</h2>
<p>Please see <strong><a href="https://cxx.rs">https://cxx.rs</a></strong> for a tutorial, reference material, and
example code.</p>
<br>
<h2 id="overview"><a class="doc-anchor" href="#overview">§</a>Overview</h2>
<p>The idea is that we define the signatures of both sides of our FFI boundary
embedded together in one Rust module (the next section shows an example).
From this, CXX receives a complete picture of the boundary to perform static
analyses against the types and function signatures to uphold both Rust’s and
C++’s invariants and requirements.</p>
<p>If everything checks out statically, then CXX uses a pair of code generators
to emit the relevant <code>extern "C"</code> signatures on both sides together with any
necessary static assertions for later in the build process to verify
correctness. On the Rust side this code generator is simply an attribute
procedural macro. On the C++ side it can be a small Cargo build script if
your build is managed by Cargo, or for other build systems like Bazel or
Buck we provide a command line tool which generates the header and source
file and should be easy to integrate.</p>
<p>The resulting FFI bridge operates at zero or negligible overhead, i.e. no
copying, no serialization, no memory allocation, no runtime checks needed.</p>
<p>The FFI signatures are able to use native types from whichever side they
please, such as Rust’s <code>String</code> or C++’s <code>std::string</code>, Rust’s <code>Box</code> or
C++’s <code>std::unique_ptr</code>, Rust’s <code>Vec</code> or C++’s <code>std::vector</code>, etc in any
combination. CXX guarantees an ABI-compatible signature that both sides
understand, based on builtin bindings for key standard library types to
expose an idiomatic API on those types to the other language. For example
when manipulating a C++ string from Rust, its <code>len()</code> method becomes a call
of the <code>size()</code> member function defined by C++; when manipulation a Rust
string from C++, its <code>size()</code> member function calls Rust’s <code>len()</code>.</p>
<br>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<p>In this example we are writing a Rust application that wishes to take
advantage of an existing C++ client for a large-file blobstore service. The
blobstore supports a <code>put</code> operation for a discontiguous buffer upload. For
example we might be uploading snapshots of a circular buffer which would
tend to consist of 2 chunks, or fragments of a file spread across memory for
some other reason.</p>
<p>A runnable version of this example is provided under the <em>demo</em> directory of
<a href="https://github.com/dtolnay/cxx">https://github.com/dtolnay/cxx</a>. To try it out, run <code>cargo run</code> from that
directory.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[cxx::bridge]
</span><span class="kw">mod </span>ffi {
    <span class="comment">// Any shared structs, whose fields will be visible to both languages.
    </span><span class="kw">struct </span>BlobMetadata {
        size: usize,
        tags: Vec&lt;String&gt;,
    }

    <span class="kw">extern </span><span class="string">"Rust" </span>{
        <span class="comment">// Zero or more opaque types which both languages can pass around but
        // only Rust can see the fields.
        </span><span class="kw">type </span>MultiBuf;

        <span class="comment">// Functions implemented in Rust.
        </span><span class="kw">fn </span>next_chunk(buf: <span class="kw-2">&amp;mut </span>MultiBuf) -&gt; <span class="kw-2">&amp;</span>[u8];
    }

    <span class="kw">unsafe extern </span><span class="string">"C++" </span>{
        <span class="comment">// One or more headers with the matching C++ declarations. Our code
        // generators don't read it but it gets #include'd and used in static
        // assertions to ensure our picture of the FFI boundary is accurate.
        </span><span class="macro">include!</span>(<span class="string">"demo/include/blobstore.h"</span>);

        <span class="comment">// Zero or more opaque types which both languages can pass around but
        // only C++ can see the fields.
        </span><span class="kw">type </span>BlobstoreClient;

        <span class="comment">// Functions implemented in C++.
        </span><span class="kw">fn </span>new_blobstore_client() -&gt; UniquePtr&lt;BlobstoreClient&gt;;
        <span class="kw">fn </span>put(<span class="kw-2">&amp;</span><span class="self">self</span>, parts: <span class="kw-2">&amp;mut </span>MultiBuf) -&gt; u64;
        <span class="kw">fn </span>tag(<span class="kw-2">&amp;</span><span class="self">self</span>, blobid: u64, tag: <span class="kw-2">&amp;</span>str);
        <span class="kw">fn </span>metadata(<span class="kw-2">&amp;</span><span class="self">self</span>, blobid: u64) -&gt; BlobMetadata;
    }
}</code></pre></div>
<p>Now we simply provide Rust definitions of all the things in the <code>extern "Rust"</code> block and C++ definitions of all the things in the <code>extern "C++"</code>
block, and get to call back and forth safely.</p>
<p>Here are links to the complete set of source files involved in the demo:</p>
<ul>
<li><a href="https://github.com/dtolnay/cxx/blob/master/demo/src/main.rs">demo/src/main.rs</a></li>
<li><a href="https://github.com/dtolnay/cxx/blob/master/demo/build.rs">demo/build.rs</a></li>
<li><a href="https://github.com/dtolnay/cxx/blob/master/demo/include/blobstore.h">demo/include/blobstore.h</a></li>
<li><a href="https://github.com/dtolnay/cxx/blob/master/demo/src/blobstore.cc">demo/src/blobstore.cc</a></li>
</ul>
<p>To look at the code generated in both languages for the example by the CXX
code generators:</p>
<div class="example-wrap"><pre class="language-console"><code>   # run Rust code generator and print to stdout
   # (requires https://github.com/dtolnay/cargo-expand)
$ cargo expand --manifest-path demo/Cargo.toml

   # run C++ code generator and print to stdout
$ cargo run --manifest-path gen/cmd/Cargo.toml -- demo/src/main.rs
</code></pre></div><br>
<h2 id="details"><a class="doc-anchor" href="#details">§</a>Details</h2>
<p>As seen in the example, the language of the FFI boundary involves 3 kinds of
items:</p>
<ul>
<li>
<p><strong>Shared structs</strong> — their fields are made visible to both
languages. The definition written within cxx::bridge is the single source
of truth.</p>
</li>
<li>
<p><strong>Opaque types</strong> — their fields are secret from the other language.
These cannot be passed across the FFI by value but only behind an
indirection, such as a reference <code>&amp;</code>, a Rust <code>Box</code>, or a <code>UniquePtr</code>. Can
be a type alias for an arbitrarily complicated generic language-specific
type depending on your use case.</p>
</li>
<li>
<p><strong>Functions</strong> — implemented in either language, callable from the
other language.</p>
</li>
</ul>
<p>Within the <code>extern "Rust"</code> part of the CXX bridge we list the types and
functions for which Rust is the source of truth. These all implicitly refer
to the <code>super</code> module, the parent module of the CXX bridge. You can think of
the two items listed in the example above as being like <code>use super::MultiBuf</code> and <code>use super::next_chunk</code> except re-exported to C++. The
parent module will either contain the definitions directly for simple
things, or contain the relevant <code>use</code> statements to bring them into scope
from elsewhere.</p>
<p>Within the <code>extern "C++"</code> part, we list types and functions for which C++ is
the source of truth, as well as the header(s) that declare those APIs. In
the future it’s possible that this section could be generated bindgen-style
from the headers but for now we need the signatures written out; static
assertions will verify that they are accurate.</p>
<p>Your function implementations themselves, whether in C++ or Rust, <em>do not</em>
need to be defined as <code>extern "C"</code> ABI or no_mangle. CXX will put in the
right shims where necessary to make it all work.</p>
<br>
<h2 id="comparison-vs-bindgen-and-cbindgen"><a class="doc-anchor" href="#comparison-vs-bindgen-and-cbindgen">§</a>Comparison vs bindgen and cbindgen</h2>
<p>Notice that with CXX there is repetition of all the function signatures:
they are typed out once where the implementation is defined (in C++ or Rust)
and again inside the cxx::bridge module, though compile-time assertions
guarantee these are kept in sync. This is different from <a href="https://github.com/rust-lang/rust-bindgen">bindgen</a> and
<a href="https://github.com/eqrion/cbindgen/">cbindgen</a> where function signatures are typed by a human once and the tool
consumes them in one language and emits them in the other language.</p>
<p>This is because CXX fills a somewhat different role. It is a lower level
tool than bindgen or cbindgen in a sense; you can think of it as being a
replacement for the concept of <code>extern "C"</code> signatures as we know them,
rather than a replacement for a bindgen. It would be reasonable to build a
higher level bindgen-like tool on top of CXX which consumes a C++ header
and/or Rust module (and/or IDL like Thrift) as source of truth and generates
the cxx::bridge, eliminating the repetition while leveraging the static
analysis safety guarantees of CXX.</p>
<p>But note in other ways CXX is higher level than the bindgens, with rich
support for common standard library types. Frequently with bindgen when we
are dealing with an idiomatic C++ API we would end up manually wrapping that
API in C-style raw pointer functions, applying bindgen to get unsafe raw
pointer Rust functions, and replicating the API again to expose those
idiomatically in Rust. That’s a much worse form of repetition because it is
unsafe all the way through.</p>
<p>By using a CXX bridge as the shared understanding between the languages,
rather than <code>extern "C"</code> C-style signatures as the shared understanding,
common FFI use cases become expressible using 100% safe code.</p>
<p>It would also be reasonable to mix and match, using CXX bridge for the 95%
of your FFI that is straightforward and doing the remaining few oddball
signatures the old fashioned way with bindgen and cbindgen, if for some
reason CXX’s static restrictions get in the way. Please file an issue if you
end up taking this approach so that we know what ways it would be worthwhile
to make the tool more expressive.</p>
<br>
<h2 id="cargo-based-setup"><a class="doc-anchor" href="#cargo-based-setup">§</a>Cargo-based setup</h2>
<p>For builds that are orchestrated by Cargo, you will use a build script that
runs CXX’s C++ code generator and compiles the resulting C++ code along with
any other C++ code for your crate.</p>
<p>The canonical build script is as follows. The indicated line returns a
<a href="https://docs.rs/cc/1.0/cc/struct.Build.html"><code>cc::Build</code></a> instance (from the usual widely used <code>cc</code> crate) on which you
can set up any additional source files and compiler flags as normal.</p>
<div class="example-wrap"><pre class="language-toml"><code># Cargo.toml

[build-dependencies]
cxx-build = &quot;1.0&quot;
</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// build.rs

</span><span class="kw">fn </span>main() {
    cxx_build::bridge(<span class="string">"src/main.rs"</span>)  <span class="comment">// returns a cc::Build
        </span>.file(<span class="string">"src/demo.cc"</span>)
        .std(<span class="string">"c++11"</span>)
        .compile(<span class="string">"cxxbridge-demo"</span>);

    <span class="macro">println!</span>(<span class="string">"cargo:rerun-if-changed=src/main.rs"</span>);
    <span class="macro">println!</span>(<span class="string">"cargo:rerun-if-changed=src/demo.cc"</span>);
    <span class="macro">println!</span>(<span class="string">"cargo:rerun-if-changed=include/demo.h"</span>);
}</code></pre></div>
<p><br><br></p>
<h2 id="non-cargo-setup"><a class="doc-anchor" href="#non-cargo-setup">§</a>Non-Cargo setup</h2>
<p>For use in non-Cargo builds like Bazel or Buck, CXX provides an alternate
way of invoking the C++ code generator as a standalone command line tool.
The tool is packaged as the <code>cxxbridge-cmd</code> crate on crates.io or can be
built from the <em>gen/cmd</em> directory of <a href="https://github.com/dtolnay/cxx">https://github.com/dtolnay/cxx</a>.</p>
<div class="example-wrap"><pre class="language-bash"><code>$ cargo install cxxbridge-cmd

$ cxxbridge src/main.rs --header &gt; path/to/mybridge.h
$ cxxbridge src/main.rs &gt; path/to/mybridge.cc
</code></pre></div><br>
<h2 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h2>
<p>Be aware that the design of this library is intentionally restrictive and
opinionated! It isn’t a goal to be powerful enough to handle arbitrary
signatures in either language. Instead this project is about carving out a
reasonably expressive set of functionality about which we can make useful
safety guarantees today and maybe extend over time. You may find that it
takes some practice to use CXX bridge effectively as it won’t work in all
the ways that you are used to.</p>
<p>Some of the considerations that go into ensuring safety are:</p>
<ul>
<li>
<p>By design, our paired code generators work together to control both sides
of the FFI boundary. Ordinarily in Rust writing your own <code>extern "C"</code>
blocks is unsafe because the Rust compiler has no way to know whether the
signatures you’ve written actually match the signatures implemented in the
other language. With CXX we achieve that visibility and know what’s on the
other side.</p>
</li>
<li>
<p>Our static analysis detects and prevents passing types by value that
shouldn’t be passed by value from C++ to Rust, for example because they
may contain internal pointers that would be screwed up by Rust’s move
behavior.</p>
</li>
<li>
<p>To many people’s surprise, it is possible to have a struct in Rust and a
struct in C++ with exactly the same layout / fields / alignment /
everything, and still not the same ABI when passed by value. This is a
longstanding bindgen bug that leads to segfaults in absolutely
correct-looking code (<a href="https://github.com/rust-lang/rust-bindgen/issues/778">rust-lang/rust-bindgen#778</a>). CXX knows about this
and can insert the necessary zero-cost workaround transparently where
needed, so go ahead and pass your structs by value without worries. This
is made possible by owning both sides of the boundary rather than just
one.</p>
</li>
<li>
<p>Template instantiations: for example in order to expose a UniquePtr&lt;T&gt;
type in Rust backed by a real C++ unique_ptr, we have a way of using a
Rust trait to connect the behavior back to the template instantiations
performed by the other language.</p>
</li>
</ul>
<br>
<h2 id="builtin-types"><a class="doc-anchor" href="#builtin-types">§</a>Builtin types</h2>
<p>In addition to all the primitive types (i32 &lt;=&gt; int32_t), the
following common types may be used in the fields of shared structs and the
arguments and returns of functions.</p>
<table>
<tr><th>name in Rust</th><th>name in C++</th><th>restrictions</th></tr>
<tr><td>String</td><td>rust::String</td><td></td></tr>
<tr><td>&amp;str</td><td>rust::Str</td><td></td></tr>
<tr><td>&amp;[T]</td><td>rust::Slice&lt;const T&gt;</td><td><sup><i>cannot hold opaque C++ type</i></sup></td></tr>
<tr><td>&amp;mut [T]</td><td>rust::Slice&lt;T&gt;</td><td><sup><i>cannot hold opaque C++ type</i></sup></td></tr>
<tr><td><a href="struct.CxxString.html">CxxString</a></td><td>std::string</td><td><sup><i>cannot be passed by value</i></sup></td></tr>
<tr><td>Box&lt;T&gt;</td><td>rust::Box&lt;T&gt;</td><td><sup><i>cannot hold opaque C++ type</i></sup></td></tr>
<tr><td><a href="struct.UniquePtr.html">UniquePtr&lt;T&gt;</a></td><td>std::unique_ptr&lt;T&gt;</td><td><sup><i>cannot hold opaque Rust type</i></sup></td></tr>
<tr><td><a href="struct.SharedPtr.html">SharedPtr&lt;T&gt;</a></td><td>std::shared_ptr&lt;T&gt;</td><td><sup><i>cannot hold opaque Rust type</i></sup></td></tr>
<tr><td>[T; N]</td><td>std::array&lt;T, N&gt;</td><td><sup><i>cannot hold opaque C++ type</i></sup></td></tr>
<tr><td>Vec&lt;T&gt;</td><td>rust::Vec&lt;T&gt;</td><td><sup><i>cannot hold opaque C++ type</i></sup></td></tr>
<tr><td><a href="struct.CxxVector.html">CxxVector&lt;T&gt;</a></td><td>std::vector&lt;T&gt;</td><td><sup><i>cannot be passed by value, cannot hold opaque Rust type</i></sup></td></tr>
<tr><td>*mut T, *const T</td><td>T*, const T*</td><td><sup><i>fn with a raw pointer argument must be declared unsafe to call</i></sup></td></tr>
<tr><td>fn(T, U) -&gt; V</td><td>rust::Fn&lt;V(T, U)&gt;</td><td><sup><i>only passing from Rust to C++ is implemented so far</i></sup></td></tr>
<tr><td>Result&lt;T&gt;</td><td>throw/catch</td><td><sup><i>allowed as return type only</i></sup></td></tr>
</table>
<p>The C++ API of the <code>rust</code> namespace is defined by the <em>include/cxx.h</em> file
in <a href="https://github.com/dtolnay/cxx">https://github.com/dtolnay/cxx</a>. You will need to include this header in
your C++ code when working with those types.</p>
<p>The following types are intended to be supported “soon” but are just not
implemented yet. I don’t expect any of these to be hard to make work but
it’s a matter of designing a nice API for each in its non-native language.</p>
<table>
<tr><th>name in Rust</th><th>name in C++</th></tr>
<tr><td>BTreeMap&lt;K, V&gt;</td><td><sup><i>tbd</i></sup></td></tr>
<tr><td>HashMap&lt;K, V&gt;</td><td><sup><i>tbd</i></sup></td></tr>
<tr><td>Arc&lt;T&gt;</td><td><sup><i>tbd</i></sup></td></tr>
<tr><td>Option&lt;T&gt;</td><td><sup><i>tbd</i></sup></td></tr>
<tr><td><sup><i>tbd</i></sup></td><td>std::map&lt;K, V&gt;</td></tr>
<tr><td><sup><i>tbd</i></sup></td><td>std::unordered_map&lt;K, V&gt;</td></tr>
</table></div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="kind/index.html" title="mod cxx::kind">kind</a></div><div class="desc docblock-short">Marker types identifying Rust’s knowledge about an extern C++ type.</div></li><li><div class="item-name"><a class="mod" href="memory/index.html" title="mod cxx::memory">memory</a></div><div class="desc docblock-short">Less used details of <code>UniquePtr</code> and <code>SharedPtr</code>.</div></li><li><div class="item-name"><a class="mod" href="vector/index.html" title="mod cxx::vector">vector</a></div><div class="desc docblock-short">Less used details of <code>CxxVector</code>.</div></li></ul><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.let_cxx_string.html" title="macro cxx::let_cxx_string">let_<wbr>cxx_<wbr>string</a></div><div class="desc docblock-short">Construct a C++ std::string on the Rust stack.</div></li><li><div class="item-name"><a class="macro" href="macro.type_id.html" title="macro cxx::type_id">type_id</a></div><div class="desc docblock-short">For use in impls of the <code>ExternType</code> trait. See <a href="trait.ExternType.html"><code>ExternType</code></a>.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.CxxString.html" title="struct cxx::CxxString">CxxString</a></div><div class="desc docblock-short">Binding to C++ <code>std::string</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.CxxVector.html" title="struct cxx::CxxVector">CxxVector</a></div><div class="desc docblock-short">Binding to C++ <code>std::vector&lt;T, std::allocator&lt;T&gt;&gt;</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Exception.html" title="struct cxx::Exception">Exception</a></div><div class="desc docblock-short">Exception thrown from an <code>extern "C++"</code> function.</div></li><li><div class="item-name"><a class="struct" href="struct.SharedPtr.html" title="struct cxx::SharedPtr">Shared<wbr>Ptr</a></div><div class="desc docblock-short">Binding to C++ <code>std::shared_ptr&lt;T&gt;</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.UniquePtr.html" title="struct cxx::UniquePtr">Unique<wbr>Ptr</a></div><div class="desc docblock-short">Binding to C++ <code>std::unique_ptr&lt;T, std::default_delete&lt;T&gt;&gt;</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.WeakPtr.html" title="struct cxx::WeakPtr">WeakPtr</a></div><div class="desc docblock-short">Binding to C++ <code>std::weak_ptr&lt;T&gt;</code>.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.ExternType.html" title="trait cxx::ExternType">Extern<wbr>Type</a></div><div class="desc docblock-short">A type for which the layout is determined by its C++ definition.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.String.html" title="type cxx::String">String</a></div><div class="desc docblock-short">Synonym for <code>CxxString</code>.</div></li><li><div class="item-name"><a class="type" href="type.Vector.html" title="type cxx::Vector">Vector</a></div><div class="desc docblock-short">Synonym for <code>CxxVector</code>.</div></li></ul><h2 id="attributes" class="section-header">Attribute Macros<a href="#attributes" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="attr" href="attr.bridge.html" title="attr cxx::bridge">bridge</a></div><div class="desc docblock-short"><code>#[cxx::bridge] mod ffi { ... }</code></div></li></ul></section></div></main></body></html>
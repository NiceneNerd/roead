<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Smart String"><title>smartstring - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-b25d77b18a16a9a4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="smartstring" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0-nightly (506052d49 2024-08-16)" data-channel="nightly" data-search-js="search-ef54e092fea9c776.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-cb0df477c2d67d00.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../smartstring/index.html">smartstring</a><span class="version">1.0.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">smartstring</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/smartstring/lib.rs.html#5-969">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="smart-string"><a class="doc-anchor" href="#smart-string">§</a>Smart String</h2>
<p><a href="struct.SmartString.html" title="struct smartstring::SmartString"><code>SmartString</code></a> is a wrapper around <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> which offers
automatic inlining of small strings. It comes in two flavours:
<a href="struct.LazyCompact.html" title="struct smartstring::LazyCompact"><code>LazyCompact</code></a>, which takes up exactly as much space as a <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>
and is generally a little faster, and <a href="struct.Compact.html" title="struct smartstring::Compact"><code>Compact</code></a>, which is the same as
<a href="struct.LazyCompact.html" title="struct smartstring::LazyCompact"><code>LazyCompact</code></a> except it will aggressively re-inline any expanded
<a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>s which become short enough to do so.
<a href="struct.LazyCompact.html" title="struct smartstring::LazyCompact"><code>LazyCompact</code></a> is the default, and what you should be using unless
you care considerably more about heap memory usage than performance.</p>
<h3 id="what-is-it-for"><a class="doc-anchor" href="#what-is-it-for">§</a>What Is It For?</h3>
<p>The intended use for <a href="struct.SmartString.html" title="struct smartstring::SmartString"><code>SmartString</code></a> is as a key type for a
B-tree (such as <a href="https://doc.rust-lang.org/nightly/alloc/collections/btree/map/struct.BTreeMap.html" title="struct alloc::collections::btree::map::BTreeMap"><code>std::collections::BTreeMap</code></a>) or any kind of
array operation where cache locality is critical.</p>
<p>In general, it’s a nice data type for reducing your heap allocations and
increasing the locality of string data. If you use <a href="struct.SmartString.html" title="struct smartstring::SmartString"><code>SmartString</code></a>
as a drop-in replacement for <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>, you’re almost certain to see
a slight performance boost, as well as slightly reduced memory usage.</p>
<h3 id="how-to-use-it"><a class="doc-anchor" href="#how-to-use-it">§</a>How To Use It?</h3>
<p><a href="struct.SmartString.html" title="struct smartstring::SmartString"><code>SmartString</code></a> has the exact same API as <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>,
all the clever bits happen automatically behind the scenes, so you could just:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>smartstring::alias::String;
<span class="kw">use </span>std::fmt::Write;

<span class="kw">let </span><span class="kw-2">mut </span>string = String::new();
string.push_str(<span class="string">"This is just a string!"</span>);
string.clear();
<span class="macro">write!</span>(string, <span class="string">"Hello Joe!"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"Hello Joe!"</span>, string);</code></pre></div>
<h3 id="give-me-the-details"><a class="doc-anchor" href="#give-me-the-details">§</a>Give Me The Details</h3>
<p><a href="struct.SmartString.html" title="struct smartstring::SmartString"><code>SmartString</code></a> is the same size as <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> and
relies on pointer alignment to be able to store a discriminant bit in its
inline form that will never be present in its <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> form, thus
giving us 24 bytes (on 64-bit architectures) minus one bit to encode our
inline string. It uses 23 bytes to store the string data and the remaining
7 bits to encode the string’s length. When the available space is exceeded,
it swaps itself out with a boxed string type containing its previous
contents. Likewise, if the string’s length should drop below its inline
capacity again, it deallocates the string and moves its contents inline.</p>
<p>In <a href="struct.Compact.html" title="struct smartstring::Compact"><code>Compact</code></a> mode, it is aggressive about inlining strings, meaning that if you modify a heap allocated
string such that it becomes short enough for inlining, it will be inlined immediately
and the allocated <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> will be dropped. This may cause multiple
unintended allocations if you repeatedly adjust your string’s length across the
inline capacity threshold, so if your string’s construction can get
complicated and you’re relying on performance during construction, it might be better
to construct it as a <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> and convert it once construction is done.</p>
<p><a href="struct.LazyCompact.html" title="struct smartstring::LazyCompact"><code>LazyCompact</code></a> looks the same as <a href="struct.Compact.html" title="struct smartstring::Compact"><code>Compact</code></a>, except
it never re-inlines a string that’s already been heap allocated, instead
keeping the allocation around in case it needs it. This makes for less
cache local strings, but is the best choice if you’re more worried about
time spent on unnecessary allocations than cache locality.</p>
<h3 id="performance"><a class="doc-anchor" href="#performance">§</a>Performance</h3>
<p>It doesn’t aim to be more performant than <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> in the general case,
except that it doesn’t trigger heap allocations for anything shorter than
its inline capacity and so can be reasonably expected to exceed
<a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>’s performance perceptibly on shorter strings, as well as being more
memory efficient in these cases. There will always be a slight overhead on all
operations on boxed strings, compared to <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>.</p>
<h3 id="feature-flags"><a class="doc-anchor" href="#feature-flags">§</a>Feature Flags</h3>
<p><code>smartstring</code> comes with optional support for the following crates through Cargo
feature flags. You can enable them in your <code>Cargo.toml</code> file like this:</p>
<div class="example-wrap"><pre class="language-no_compile"><code>[dependencies]
smartstring = { version = &quot;*&quot;, features = [&quot;proptest&quot;, &quot;serde&quot;] }
</code></pre></div><div><table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/crates/arbitrary"><code>arbitrary</code></a></td><td><a href="https://docs.rs/arbitrary/latest/arbitrary/trait.Arbitrary.html"><code>Arbitrary</code></a> implementation for <a href="struct.SmartString.html" title="struct smartstring::SmartString"><code>SmartString</code></a>.</td></tr>
<tr><td><a href="https://crates.io/crates/proptest"><code>proptest</code></a></td><td>A strategy for generating <a href="struct.SmartString.html" title="struct smartstring::SmartString"><code>SmartString</code></a>s from a regular expression.</td></tr>
<tr><td><a href="https://crates.io/crates/serde"><code>serde</code></a></td><td><a href="https://docs.rs/serde/latest/serde/trait.Serialize.html"><code>Serialize</code></a> and <a href="https://docs.rs/serde/latest/serde/trait.Deserialize.html"><code>Deserialize</code></a> implementations for <a href="struct.SmartString.html" title="struct smartstring::SmartString"><code>SmartString</code></a>.</td></tr>
</tbody></table>
</div></div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="alias/index.html" title="mod smartstring::alias">alias</a></div><div class="desc docblock-short">Convenient type aliases.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Compact.html" title="struct smartstring::Compact">Compact</a></div><div class="desc docblock-short">A compact string representation equal to <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> in size with guaranteed inlining.</div></li><li><div class="item-name"><a class="struct" href="struct.Drain.html" title="struct smartstring::Drain">Drain</a></div><div class="desc docblock-short">A draining iterator for a <a href="struct.SmartString.html" title="struct smartstring::SmartString"><code>SmartString</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.LazyCompact.html" title="struct smartstring::LazyCompact">Lazy<wbr>Compact</a></div><div class="desc docblock-short">A representation similar to <a href="struct.Compact.html" title="struct smartstring::Compact"><code>Compact</code></a> but which doesn’t re-inline strings.</div></li><li><div class="item-name"><a class="struct" href="struct.SmartString.html" title="struct smartstring::SmartString">Smart<wbr>String</a></div><div class="desc docblock-short">A smart string.</div></li></ul><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.MAX_INLINE.html" title="constant smartstring::MAX_INLINE">MAX_<wbr>INLINE</a></div><div class="desc docblock-short">The maximum capacity of an inline string, in bytes.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.SmartStringMode.html" title="trait smartstring::SmartStringMode">Smart<wbr>String<wbr>Mode</a></div><div class="desc docblock-short">Marker trait for <a href="struct.SmartString.html" title="struct smartstring::SmartString"><code>SmartString</code></a> representations.</div></li></ul></section></div></main></body></html>